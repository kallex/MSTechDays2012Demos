<#@ template debug="true" hostSpecific="true" #>
<#@ output extension="?" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Xml.dll" #>
<#@ Assembly Name="System.Xml.Linq.dll" #>
<#@ Assembly Name="System.Windows.Forms.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Serialization" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ include file="..\..\..\abscommon\CommonInclude\Common\CommonCodeblocks.ttinclude" #>
<#@ include file="absbuilder_v1_0.ttinclude" #>
<#   
	string templateDirectoryName = Path.GetDirectoryName(Host.TemplateFile);
	string directoryName = templateDirectoryName + @"\In\Content_v1_0";
	string outputContentName = templateDirectoryName + @"\Out\Builder.designer.cs";
	directoryName = directoryName.Replace(@"absbuilder\AbstractionBuilder", "AbstractionContent");
	outputContentName = outputContentName.Replace(@"absbuilder\AbstractionBuilder", "AbstractionContent");
	string[] xmlFileNames = Directory.GetFiles(directoryName, "*.xml");

	#>
using System;

	<#
	
	foreach(string xmlFileName in xmlFileNames)
	{
		AbstractionBuilderType absbuilder = LoadXml<AbstractionBuilderType>(xmlFileName);
		GenerateBuilder(absbuilder.Builder);
	}
	
	File.WriteAllText(outputContentName, this.GenerationEnvironment.ToString());
 
#>
<#+ 
	#region Class Level Variable Block

	void SetCurrentAbstraction(object abs)
	{
		throw new NotSupportedException("Builder does not run xml config");
	}
	
	private BuilderType CurrBuilder;
	
	void GenerateBuilder(BuilderType builder)
	{
		CurrBuilder = builder;
		#>
namespace AbstractionBuilder {
	partial class Builder {
        public void Build()
        {
			CleanUp();
            Tuple<string, string>[] generatorFiles = null;
		<#+
			foreach(object buildExecuteItem in builder.BuildExecution)
			{
				GenerateExecuteItem(buildExecuteItem);
			}
		#>
        }
		
		private void CleanUp()
		{
		<#+
			foreach(object buildExecuteItem in builder.BuildExecution)
			{
				GenerateCleanupItem(buildExecuteItem);
			}
		#>
		}
	}
}
		<#+
	}
	
	void GenerateCleanupItem(object executeItem)
	{
		if(executeItem == null)
			throw new ArgumentNullException("executeItem");
		AbstractionItemType absItem = executeItem as AbstractionItemType;
		TransformationItemType transItem = executeItem as TransformationItemType;
		if(absItem != null)
		{
		#>
            CleanUpAbstractionOutput("<#= absItem.nameRef #>");
		<#+
		}
		else if(transItem != null)
		{
			TransformationType targetTrans = CurrBuilder.Transformations.SingleOrDefault(item => item.name == transItem.nameRef);
			if(targetTrans == null)
				throw new ArgumentException("Target transformation for exec item not found: " + transItem.nameRef);
		#>
            CleanUpTransformationInputAndOutput("<#= targetTrans.name #>", "<#= targetTrans.targetAbstraction #>");
		<#+
		}
		else
			throw new NotSupportedException("Execute item type: " + executeItem.GetType().Name);
		
		#>
		<#+
	}

	void GenerateExecuteItem(object executeItem)
	{
		if(executeItem == null)
			throw new ArgumentNullException("executeItem");
		AbstractionItemType absItem = executeItem as AbstractionItemType;
		TransformationItemType transItem = executeItem as TransformationItemType;
		ExecutionItemType executionItem = executeItem as ExecutionItemType;
		if(absItem != null)
			GenerateAbstractionExecuteItem(absItem);
		else if(transItem != null)
			GenerateTransformationExecuteItem(transItem);
		else if(executionItem != null)
			GenerateExecutionExecuteItem(executionItem);
		else 
			throw new NotSupportedException("Execute item type: " + executeItem.GetType().Name);
	}
	
	void GenerateExecutionExecuteItem(ExecutionItemType execItem)
	{
		AbstractionType abs = CurrBuilder.Abstractions.SingleOrDefault(item => item.name == execItem.nameRef);
		if(abs == null)
		{
			throw new ArgumentException("AbstractionBuildItem referring to undefined abstraction: " + execItem.nameRef);
		}
		string absName = execItem.nameRef;
		string className = execItem.className;
		string methodName = execItem.methodName;
		#>
	        ExecuteCustomExecution("<#= absName #>", "ABS", "<#= className #>", "<#= methodName #>");
		<#+
	}

	
	void GenerateAbstractionExecuteItem(AbstractionItemType absItem)
	{
		AbstractionType abs = CurrBuilder.Abstractions.SingleOrDefault(item => item.name == absItem.nameRef);
		if(abs == null)
		{
			throw new ArgumentException("AbstractionBuildItem referring to undefined abstraction: " + absItem.nameRef);
		}
		foreach(GeneratorType generator in abs.Generator) {
		#>
	        generatorFiles = ExecuteAssemblyGenerator("<#= abs.name #>", "ABS", "<#= generator.name #>");
	        WriteGeneratorFiles(generatorFiles, "<#= abs.name #>", "ABS");
		<#+
		}
	}
	
	void GenerateTransformationExecuteItem(TransformationItemType transItem)
	{
		TransformationType trans = CurrBuilder.Transformations.SingleOrDefault(item => item.name == transItem.nameRef);
		if(trans == null)
		{
			throw new ArgumentException("TransformationBuildItem referring to undefined transformation: " + transItem.nameRef);
		}
		#>
		FetchTransformationSources("<#= trans.name #>", "<#= trans.sourceAbstraction #>");
        generatorFiles = ExecuteAssemblyGenerator("<#= trans.name #>", "TRANS", "Transformer");
        WriteGeneratorFiles(generatorFiles, "<#= trans.name #>", "TRANS");
		PushTransformationTargets("<#= trans.name #>", "<#= trans.targetAbstraction #>");
		<#+
	}
	
	
	#endregion
#>